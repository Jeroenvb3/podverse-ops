# BASE CONFIG

indexer {
    mem_limit = 256M
}

source base {
    type = pgsql
    sql_host = podverse_db
    sql_user = postgres
    sql_pass = mysecretpw
    sql_db = postgres
    sql_ranged_throttle = 50
}

# AUTHOR NAME SEARCH

source author_base: base {
    sql_field_string = name
    sql_attr_string = podverse_id
}

source author: author_base {
    sql_query = \
        SELECT \
            int_id, \
            id AS podverse_id, \
            name \
        FROM authors
}

index idx_author {
    source = author
    path = author_name
    dict = keywords
    expand_keywords = 1
    min_infix_len = 2
    charset_table = non_cjk, cjk
    rt_mem_limit = 4G
}

# EPISODE TITLE SEARCH

source episode_csv: base {
    sql_field_string = title
    sql_attr_string = podverse_id
    sql_attr_uint = pastHourTotalUniquePageviews
    sql_attr_uint = pastDayTotalUniquePageviews
    sql_attr_uint = pastWeekTotalUniquePageviews
    sql_attr_uint = pastMonthTotalUniquePageviews
    sql_attr_uint = pastYearTotalUniquePageviews
    sql_attr_uint = pastAllTimeTotalUniquePageviews
    sql_attr_timestamp = created_date
    sql_query = \
        SELECT \
            id AS podverse_id, \
            title, \
            "pastHourTotalUniquePageviews", \
            "pastDayTotalUniquePageviews", \
            "pastWeekTotalUniquePageviews", \
            "pastMonthTotalUniquePageviews", \
            "pastYearTotalUniquePageviews", \
            "pastAllTimeTotalUniquePageviews", \
            extract(epoch from "pubDate") AS created_date \
        FROM "episodes"
}

source episode_base: base {
    sql_field_string = title
    sql_attr_string = podverse_id
    sql_attr_uint = pastHourTotalUniquePageviews
    sql_attr_uint = pastDayTotalUniquePageviews
    sql_attr_uint = pastWeekTotalUniquePageviews
    sql_attr_uint = pastMonthTotalUniquePageviews
    sql_attr_uint = pastYearTotalUniquePageviews
    sql_attr_uint = pastAllTimeTotalUniquePageviews
    sql_attr_timestamp = created_date
}

source episode: episode_base {
    sql_query_range = SELECT MIN(int_id), MAX(int_id) FROM episodes
    sql_range_step = 10000
    sql_query = \
        SELECT \
            int_id, \
            id AS podverse_id, \
            title, \
            "pastHourTotalUniquePageviews", \
            "pastDayTotalUniquePageviews", \
            "pastWeekTotalUniquePageviews", \
            "pastMonthTotalUniquePageviews", \
            "pastYearTotalUniquePageviews", \
            "pastAllTimeTotalUniquePageviews", \
            extract(epoch from "pubDate") AS created_date \
        FROM episodes \
        WHERE int_id >= $start AND int_id <= $end
}

index idx_episode {
    source = episode
    path = episodes_title
    dict = keywords
    expand_keywords = 1
    min_infix_len = 2
    charset_table = non_cjk, cjk
    rt_mem_limit = 4G
}

# MEDIA_REF TITLE SEARCH

source media_ref_base: base {
    sql_field_string = title
    sql_attr_string = podverse_id
    sql_attr_uint = pastHourTotalUniquePageviews
    sql_attr_uint = pastDayTotalUniquePageviews
    sql_attr_uint = pastWeekTotalUniquePageviews
    sql_attr_uint = pastMonthTotalUniquePageviews
    sql_attr_uint = pastYearTotalUniquePageviews
    sql_attr_uint = pastAllTimeTotalUniquePageviews
    sql_attr_timestamp = created_date
}

source media_ref: media_ref_base {
    sql_query = \
        SELECT \
            int_id, \
            id AS podverse_id, \
            title, \
            "pastHourTotalUniquePageviews", \
            "pastDayTotalUniquePageviews", \
            "pastWeekTotalUniquePageviews", \
            "pastMonthTotalUniquePageviews", \
            "pastYearTotalUniquePageviews", \
            "pastAllTimeTotalUniquePageviews", \
            extract(epoch from "createdAt") AS created_date \
        FROM "mediaRefs"
}

index idx_media_ref {
    source = media_ref
    path = media_ref_title
    dict = keywords
    expand_keywords = 1
    min_infix_len = 2
    charset_table = non_cjk, cjk
    rt_mem_limit = 4G
}

# PLAYLIST TITLE SEARCH

source playlist_base: base {
    sql_field_string = title
    sql_attr_string = podverse_id
}

source playlist: playlist_base {
    sql_query = \
        SELECT \
            int_id, \
            id AS podverse_id, \
            title \
        FROM playlists
}

index idx_playlist {
    source = playlist
    path = playlist_title
    dict = keywords
    expand_keywords = 1
    min_infix_len = 2
    charset_table = non_cjk, cjk
    rt_mem_limit = 4G
}

# PODCAST TITLE SEARCH

source podcast_base: base {
    sql_field_string = title
    sql_attr_string = podverse_id
    sql_attr_uint = pastHourTotalUniquePageviews
    sql_attr_uint = pastDayTotalUniquePageviews
    sql_attr_uint = pastWeekTotalUniquePageviews
    sql_attr_uint = pastMonthTotalUniquePageviews
    sql_attr_uint = pastYearTotalUniquePageviews
    sql_attr_uint = pastAllTimeTotalUniquePageviews
    sql_attr_timestamp = created_date
}

source podcast: podcast_base {
    sql_query_range = SELECT MIN(int_id), MAX(int_id) FROM podcasts
    sql_range_step = 10000
    sql_query = \
        SELECT \
            int_id, \
            id AS podverse_id, \
            title, \
            "pastHourTotalUniquePageviews", \
            "pastDayTotalUniquePageviews", \
            "pastWeekTotalUniquePageviews", \
            "pastMonthTotalUniquePageviews", \
            "pastYearTotalUniquePageviews", \
            "pastAllTimeTotalUniquePageviews", \
            extract(epoch from "lastEpisodePubDate") AS created_date \
        FROM podcasts \
        WHERE int_id >= $start AND int_id <= $end
}

index idx_podcast {
    source = podcast
    path = podcasts_title
    dict = keywords
    expand_keywords = 1
    min_infix_len = 2
    charset_table = non_cjk, cjk
    rt_mem_limit = 4G
}

# SEARCHD CONFIG

searchd {
    listen = 9306:mysql41
    listen = 9308:http
    log = searchd.log
    query_log = query.log
    binlog_path =
    network_timeout = 5
    client_timeout = 300
    # max_children = 30
    persistent_connections_limit = 30
    pid_file = manticoresearch.pid
    seamless_rotate = 1
    preopen_indexes = 1
    unlink_old = 1
    # mva_updates_pool = 1M
    max_packet_size = 8M
    max_filters = 256
    max_filter_values = 4096
    max_batch_queries = 32
    workers = threads
    collation_server = utf8_ci
}
